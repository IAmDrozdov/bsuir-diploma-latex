\section{Раработка программного обеспечения}

\subsection{Разработка серверной части}

Структура приложения, написанного на фреймворке Django представляет собой набор отдельных приложений, выполняющих отдельные функции.
Каждое приложение вклбчает в себя:
\begin{itemize}
    \item models.py - файл, содержащий представление моделей базы данных;
    \item migrations/ - папка, хранящая миграции моделей;
    \item serialzers.py - файл, содержащий представления входных/выходных данных сервера;
    \item views.py - файл, содержащий контроллеры, обрабатывающие запросы;
    \item utils.py - файл, содержащий вспомогательные функции приложения, например сервисы обращения к третьим приложения;
    \item tasks.py - файл, содержищий асинхронные-задачи данного приложения, которые взаимодействуют с моделями это приложения, либо логически относятся к нему;
    \item tests.py - файл, содержащий тесты к контроллерам;
    \item factories.py - файл, содержащий фабрики для генерации данных для тестов;
    \item permissions.py - файл, содержащий пользовательские разрешения для запросов;
    \item signals.py - файл, содержащий сигналы для моделей БД;
    \item admin.py - файл, содержаший модели представления и модификации сайта администратора;
    \item urls.py - файл, содержищий связи между контроллерами и url-адресами.
\end{itemize}

Хоть Django фреймворк и предоставляет готовую структуру для написания веб-приложения, однако в каждом проекте присутствуют утилиты, нужные в независимости от приложения.
К таким утилитам относятся работы со структурами данных, работа с изображениями и интернализацией, миксины для контроллеров, сериализаторов либо тестов и тд.
Для таких утилит на уровне приложений была создана отдельная папка <<utils>>, содержащая модули python, разбитые по категориям:
\begin{itemize}
    \item strings.py - файл, содержащий утилиты для работы со строками;
    \item tests.py - папка, содержащий утилиты для работы с тестами;
    \item constants.py - файл, содержащий константы приложения;
    \item mixins.py - файл, содержащий миксины для сериализаторов и контроллеров;
    \item images.py - файл, содержащий утилиты для работы с изображениями;
    \item i18l.py - файл, содержащий утилиты для рабоыт с интернализацией;
    \item models.py - файл, содержащий утилиты для рабоыт с моделями.
\end{itemize}

Для предоставления возможности масштабирования системы была выбрана плоская структура конечных точек HTTP[19].
Данная структура характеризуется большим объемом мелких конечных точек, отвечающих за отдельные сущность.
Одновременно минусом и плюсом данной структуры является, как оговаривалось раньше, возможность получения конкретных объектов базы данных по средством отдельных конечных точек.
Таким образом, например, для получения всех данных о пользователе, клиент должен будеть послать несколько запросов к серверу.
Данная архитектура увеличивает количество запросов к серверу, однако сложно представить, что на одной странице клиента будут отображены все данные о пользователе.
И при нескольких конечных точках возможно, при ее необходимости, закгрузка данных в фоне.

На основании выбора плоской архитектуры к организации программного интерфейса к серверной части приложения были реализованы приложения: Auth, Users, Goods, Payments, Orders, Addresses (таблица 4.1).
Итоговая структура проекта представлена на рисунке \ref{back:struct}.

\begin{figure}[h!]
    \begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[scale=0.8]{structure_1.png}
    \caption{}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[scale=0.8]{structure_2.png}
    \caption{}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[scale=0.8]{structure_3.png}
    \caption{}
    \end{subfigure}
    \caption{ Структура серверной части приложения }
    \label{back:struct}
\end{figure}

\begin{table}
    \caption{Приложения серверной части}
    \begin{tabular}{ | l | p{6cm} | }
        \hline
        Название приложения & Выполняющие функции \\ \hline
        Auth & Отвечает за процесс авторизации пользователя в системе \\ \hline
        Users & Отвечает за манипуляции с пользовательскими данными \\ \hline
        Goods & Отвечает за доступ к товарам и взаимодействия с ними \\ \hline
        Payments & Хранения сохранненых данных для оплаты пользователя\\ \hline
        Orders & Хранения и соверщение заказов пользователя \\ \hline
        Addresses & Хранения адресов оплаты пользователя \\ \hline
    \end{tabular}
\end{table}


\subsubsection{Программный интерфейс серверной части}\hfill

На основании функциональных требований в каждом приложении были реализованы API конечных точек HTTP-запросов (таблицы 4.2-4.7).

\begin{table}
    \caption{Приложение Auth, базовый url адрес конечных точек <</auth>>}
    \begin{tabular}{ | p{3cm} | p{4cm} | p{3cm} | p{3cm} | }
        \hline
        url-адрес запроса / метод запроса & входные данные & выходные данные  & описание \\ \hline
    /verify POST  & phone - номер телефона, token - токен, выданные firebase, после вводна OTP кода & token - токен авторизации пользователя для осузествления запросов к серверу & С помощью данного запроса пользователь может авторизироваться в приложении с помощью токена \\ \hline
    \end{tabular}
\end{table}

\begin{table}
    \caption{Приложение Users, базовый url адрес конечных точек <</users>>}
    \begin{tabular}{ | p{3cm} | p{4cm} | p{3cm} | p{3cm} | }
        \hline
        url-адрес запроса / метод запроса & входные данные & выходные данные  & описание \\ \hline
        / POST & name - ФИО пользователя, photo - фото пользователя & созданная модель пользователя & создание пользователя в системе \\ \hline
        / PUT & name - ФИО пользователя, photo - фото пользователя, email - электронная почта пользователя & обновленная модель пользователя & обновление данных пользователя \\ \hline
        /ID/review POST & text - текст отзыва, mark - оценка пользователя & & создание отзыва о пользователе \\ \hline
        / GET & & получение информации о пользователе \\ \hline
    \end{tabular}
\end{table}

\begin{table}
    \caption{Приложение Addresses, базовый url адрес конечных точек <</addresses>>}
    \begin{tabular}{ | p{3cm} | p{4cm} | p{3cm} | p{3cm} | }
        \hline
        url-адрес запроса / метод запроса & входные данные & выходные данные  & описание \\ \hline
        / POST & city - город получателя, street - улица получателя, building - номер здания получателя, appartament - номер квартиры получателя & созданная модель адреса & создания адреса доставки пользователя \\ \hline
        /ID PUT & city - город получателя, street - улица получателя, building - номер здания получателя, appartament - номер квартиры получателя & обновленная модель адреса & обновление адреса доставки пользователя \\ \hline
        /ID DELETE & & & удаление адреса доставки пользователя \\ \hline
        / GET & & & получение всех сохраенных записей адресов \\ \hline
    \end{tabular}
\end{table}

\begin{table}
    \caption{Приложение Payments, базовый url адрес конечных точек <</payments>>}
    \begin{tabular}{ | p{3cm} | p{4cm} | p{3cm} | p{3cm} | }
        \hline
        url-адрес запроса / метод запроса & входные данные & выходные данные  & описание \\ \hline
        / POST & card\_number - номер карты пользователя, cvv\_code - cvv-код карты, date\_expire - срок годности карты, cardholder\_name - имя держателя карты & созданная модель оплаты & создание модели оплаты пользователя \\ \hline
        /ID PUT & card\_number - номер карты пользователя, cvv\_code - cvv-код карты, date\_expire - срок годности карты, cardholder\_name - имя держателя карты & обновленная модель оплаты & обновление модели оплаты пользователя \\ \hline
        /ID DELETE & & & удаление модели оплаты \\ \hline
        / GET & & & получение всех сохраенных записей оплат \\ \hline
    \end{tabular}
\end{table}

\begin{table}
    \caption{Приложение Goods, базовый url адрес конечных точек <</goods>>}
    \begin{tabular}{ | p{3cm} | p{4cm} | p{3cm} | p{3cm} | }
        \hline
        url-адрес запроса / метод запроса & входные данные & выходные данные  & описание \\ \hline
        /add POST & name - название товара, condition - состояние товара, description - описание товара, can\_be\_purchased - возможность выкупа товара, price\_per\_hour - цена аренды товара за час, price\_per\_day - цена аренды товара за сутки, own\_deliver - возможность доставки товара арендадателем & созданная модель товара & создания товара \\ \hline
        /ID PUT & name - название товара, condition - состояние товара, description - описание товара, can\_be\_purchased - возможность выкупа товара, price\_per\_hour - цена аренды товара за час, price\_per\_day - цена аренды товара за сутки, own\_deliver - возможность доставки товара арендадателем & обновленная модель товара & обновление информации о товаре \\ \hline
        /ID DELETE & & & удаление товара \\ \hline
        /ID/add-to-basket PUT &  & & добавление товара в корзину \\ \hline
        /ID/remove-from-basket PUT & & & удаление товара из корзины \\ \hline
        /?page=PAGE GET & PAGE - страница поисков & список моделей товаров & получить все товары \\ \hline
        /?page=PAGE \&XX=YY GET & PAGE - страница поисков, XX=элемент фильтрации, YY -  значение XX фильтра & список моделей товаров & получить все товары \\ \hline
    \end{tabular}
\end{table}

\begin{table}
    \caption{Приложение Orders, базовый url адрес конечных точек <</orders>>}
    \begin{tabular}{ | p{3cm} | p{4cm} | p{3cm} | p{3cm} | }
        \hline
        / POST & start\_use\_date - дата начала пользования, end\_use\_date - дата окончания пользования, payment - выбор оплаты, address - выбор адреса доставки & модель заказа & создание заказа \\ \hline
        /ID/pay PUT & & & оплата товара; \\ \hline
        / GET & & список моделей заказов & получение списка заказов. \\ \hline
    \end{tabular}
\end{table}

\subsection{Разработка клиентской части}

Как было описано в разделе про проектирование клиентской части, в среде React приложений нет четко выработанной структуры приложений.
Однако основываясь на практиках написания React приложений была реализованна структура приложения, представленная на рисунке \ref{front:struct}.

Глобальное состояние приложения была разделено на несколько редьюсеров:
\begin{itemize}
    \item appReducer - котнролирует глобальное состояние приложение, а именно контроль отображения загрузчиков в приложении;
    \item authReducer - контролирует изменение и процесс аунтентификации пользователя;
    \item basketReducer - контролирует состояние корзины пользователя;
    \item checkoutReducer - контролирует процесс покупки товара;
    \item filterReducer - отвечает за фильтрацию товаров на экране поиска товаров;
    \item productReducer - отвечает за создание и изменения пользовательских продуктов;
    \item profileReducer - отвечает за состяние пользовательских данных;
    \item orderReducer - отвечает за состояние пользовательских заказов;
\end{itemize}

Соответственно каждому редьюсеру были созданы саги, экшены и константы, которые провоцируют приложению на осуществление запросов на сервер либо изменение состояния.

Компоненты приложения расположены в директориях <<components>> и <<views>> таким образом, что в директории <<components>> расположены глупые компоненты, представляющие репрезентационные компоненты.
А в дирректории <<views>> расположены как экраны приложения, так и компоненты-контейнеры.
\begin{figure}[h]
    \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[scale=0.8]{front_structure_1.png}
    \caption{}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
    \centering
    \includegraphics[scale=0.8]{front_structure_2.png}
    \caption{}
    \end{subfigure}
    \caption{ Структура клиентской части приложения }
    \label{front:struct}
\end{figure}

В главе про проектирование было


\subsection{Интеграция Firebase}
В данном проекте из платформы Firebase использовались 2 модуля:
\begin{itemize}
    \item Authentication;
    \item Messaging.
\end{itemize}

На серверной части интеграция с Firebase происходит с помощью пакета firebase-admin.
Для инициализации Firebase проекта на серверной части необходимо скачать сервисный файл с панели администратора на Firebase(см рисунок \ref{fire:admin}).

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.4]{service_file.png}
    \caption{ Графический интерфейс Firebase вкладки скачивания сервисного файла }
    \label{fire:admin}
\end{figure}

Далее данный файл используется для инициализации проекта (см листинг 4.1).

Листинг 4.1 – Инициализация Firebase на серверной части
\begin{lstlisting}
    import os

    import firebase_admin

    from firebase_admin import credentials

    firebase_admin.initialize_app(
        credentials.Certificate(
            os.environ["FIREBASE_SERVICE_FILE"]
        )
    )
\end{lstlisting}

После чего в разделах ниже будет добавлен и использован функционал данной библиотеки для реализации отправки уведомлений и организации аунтентификации по номеру телефона.


В целях соблюдения концепции <<Двенадцать факторов>>, а так же облегчения развертывания проекта, инициализация проекта клиентской части происходит с помощью переменных окруженя.
Как и для серверной части, данные доступа приложения можно получить в панели администратора Firebase.

Для того, чтобы облегчить процесс использования сервисов Firebase на клиентской части, был написан сервис Firebase(см листинг 4.2).

Листинг 4.2 – Инициализация Firebase на клиентской части
\begin{lstlisting}
    import app from 'firebase/app';

    const firebaseConfig = {
      apiKey: process.env.FIREBASE_API_KEY,
      authDomain: process.env.FIREBASE_AUTH_DOMAIN,
      databaseURL: process.env.FIREBASE_DB_URL,
      projectId: process.env.FIREBASE_PROJECT_ID,
      storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
      messagingSenderId: process.env.FIREBASE_MSG_SENDER_ID,
      appId: process.env.FIREBASE_APP_ID,
      measurementId: process.env.MEASUREMENT_ID
    };

    class Firebase {
      constructor() {
        app.initializeApp(firebaseConfig);
      }

    }

    const firebase = new Firebase();

    export default firebase;

\end{lstlisting}

Сервис представляет собой синглтон, который предоставляет доступ к инициализированному приложению.
В разделах ниже в него будут добавлены необходимые функции.

\subsubsection{Использование Firebase Authentication}\hfill

Firebase обеспечивает службы серверной части, простые пакеты разработчика и готовые библиотеки интерфейса для аутентификации пользователей различных приложения на любых платформах.
На основе требований к ПО было принято решение использования модуля Firebase Authentication с провайдером аутентификации Phone Number.

В первую очередь был создан набор тестовых номеров телефонов, потому что при использовании одного и того же номера для аутентификации Firebase может блокировать этот номер на некоторое время.
Список созданных тестовых номеров представлен на рисунке \ref{fire:phones}.
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.5]{firebase_phone_list.png}
    \caption{ Список используемые тестовых номеров телефонов }
    \label{fire:phones}
\end{figure}

После этого необходимо интегрировать использование аутентификации с помощью номера телефона на клиентскую часть.

Как было сказано выше, для удобного обращения к сервисам фаербейз был разработан модуль Firebase.
В нем были реализованы функции:
\begin{itemize}
    \item Выслать OTP-код на номер телефона;
    \item Проверить OTP-код;
\end{itemize}

Прежде чем войти в систему пользователей с их телефонов, необходимо настроить средство проверки рекапчи.
Firebase использует reCAPTCHA для предотвращения злоупотреблений.
Таким образов для интеграции Firebase Authentication с помощью номера телефона необходимо создать каптчу(см листинг 4.3).
И так же организовать проверку с помощью клиентской библиотеки Firebase(см листинг 4.4).


Листинг 4.3 – Интеграция reCAPTCHA в форму аунтентификации
\begin{lstlisting}
    useEffect(() => {
        window.recaptchaVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container', {
          callback: () => setCodeSent(true),
          size: 'invisible'
        });
      }, []);
\end{lstlisting}

Листинг 4.4 – Интеграция функционала для работы с аунтентификацией по номеру телефона
\begin{lstlisting}

class Firebase {
    constructor() {
      app.initializeApp(firebaseConfig);

      this.auth = app.auth();
    }

    sendCode = (phone, appVerifier) => this.auth.signInWithPhoneNumber(phone, appVerifier);

    verifyCode = (confirmationResult, code) => confirmationResult.confirm(code);

    signOut = () => this.auth.signOut();
  }

\end{lstlisting}

После успешной проверки OTP-кода Firebase генерирует IdToken, котрый представляет собой JWT токен.
Данный токер вместе с номером телефона отправляется на серверную часть для получения токена авторизации.

Для обработки процесса аунтентификации пользователя на серверной части была реализована проверка IdToken с помощью серверной библиотеки Firebase.


Был написан сериализатор(см листинг 4.5), который средствами серверной библиотеки Firebase распаковывает IdToken и проверяет, соответствие номера телефона запроса с номером телефона в токене.

Листинг 4.5 – Сериализатор проверки код и номера телефона
\begin{lstlisting}
from django.utils.translation import ugettext_lazy as _
from phonenumber_field.serializerfields import PhoneNumberField

from rest_framework import serializers, exceptions
from utils.firebase.helpers import get_id_token


class FireBaseIDTokenSerializer(serializers.Serializer):
    fcm_token = serializers.CharField(
        allow_null=True, max_length=200
        )
    phone_number = PhoneNumberField()
    verification_code = serializers.CharField()

    def validate_verification_code(self, value):
        try:
            decoded_token = get_id_token(value)
        except ValueError:
            raise exceptions.ValidationError(
                _("Token expired!"), code="token-expired"
            )
        except Exception:
            # TODO: Add logging
            raise exceptions.ValidationError(
                _("Invalid code!"), code="token-invalid"
            )
        return decoded_token

    def validate_phone_number(self, value):
        return value.as_e164

    def validate(self, attrs):
        decoded_token = attrs["verification_code"]
        if decoded_token["phone_number"] != attrs["phone_number"]:
            raise exceptions.ValidationError(
                _("Invalid combination of phone number and code!")
            )

        return attrs

\end{lstlisting}

При неуспешной обработке токена сервер возвращает 40X ответ клиентской части с описанием ошибки.
При успешной обработке токена сервер генерирует токен авторизации и возвращает его в ответе.

\subsubsection{Использование Firebase Messaging}\hfill

Firebase Cloud Messaging (FCM) - это кросс-платформенное решение для обмена сообщениями, которое позволяет  отправлять сообщения без каких-либо затрат.

На серверной части была написана утилита для отправки уведомлений как одному пользователю, так и многим (см листинг 4.6-4.8).


Листинг 4.6 – Функция создания конфигурационного файла для отправки уведомлений
\begin{lstlisting}
    def generate_push_configs(
        title: str = None, body: str = None, url: str = ""
        ) -> messaging.WebpushConfig:

    url_site = f"https://{os.environ["SSL_DOMAIN"]}"
    redirect_to = f"{url_site}/{url}" if url else None

    webpush_config = messaging.WebpushConfig(
        notification=messaging.WebpushNotification(
            title=title,
            body=body,
        ),
        fcm_options=messaging.WebpushFcmOptions(
            link=redirect_to
        )
    )
    return webpush_config
\end{lstlisting}

Листинг 4.7 – Отправка уведомления одному пользователю
\begin{lstlisting}
    def send_push(
        user_id: int, collection: str, title: str = None,
        body: str = None, url: str = ""
        ) -> None:
    token = User.objects.get(pk=user_id).fcm_token
    if not token:
        return

    webpush_config = generate_push_configs(title, body, url)

    message = messaging.Message(
        webpush=webpush_config,
        token=token
    )
    try:
        messaging.send(message)
    except messaging.ApiCallError as e:
        logging.debug(
            f"Could send push in firebase. Error: {e}"
            )
\end{lstlisting}

Листинг 4.8 – Отправка уведомления нескольким пользователям
\begin{lstlisting}
    def send_multiple_push(
        users_ids: list, collection: str, title: str = None,
        body: str = None, url: str = ""
        ) -> None:
    tokens = (
        User.objects
        .filter(pk__in=users_ids)
        .values_list("fcm_token", flat=True)
    )
    filtered_tokens = [token for token in tokens if token]

    webpush_config = generate_push_configs(title, body)

    multicast_message = messaging.MulticastMessage(
        tokens=filtered_tokens,
        webpush=webpush_config,
    )
    try:
        messaging.send_multicast(multicast_message)
    except messaging.ApiCallError as e:
        logging.debug(
            f"Could send multicast push in firebase. Error: {e}"
            )
\end{lstlisting}

Токен для отправки уведомлений обновляется при аутентификации пользователя в системе.
Во избежании ошибок при отправке уведомлений была добавлена проверка на наличие FCM токена у пользователя.

\subsection{Развертывание программного обеспечения}
В первую очередь стоит обратить внимание на то, что данный проект состоит из трех компонент:
\begin{itemize}
    \item Клиентское приложение;
    \item Серверное приложение;
    \item База данных.
\end{itemize}

При том изобилии компонент, которое у имеется, решением для разработки было использование docker-compose.
Таким образом был написан <<docker-compose.yml>> файл(см листинг 4.9).

Листинг 4.9 – Docker-compose файл
\begin{lstlisting}
    version: "3"

    services:
    db:
        image: postgres
        ports:
        - "5432:5432"
    django:
        build: ./backend
        command: bash -c 'python manage.py
        migrate && python manage.py runserver 0.0.0.0:8000'
        ports:
        - "8000:8000"
        depends_on:
        - db
    frontend:
        build: ./frontend
        command: npm start
        volumes:
        - ./frontend:/app/frontend
        ports:
        - "8000:8000"
\end{lstlisting}


Данный файл состоит соответственно из трех сервисов: клиентское приложние, серверное приложение и база данных.
Стоит обратить внимание, что серверное приложение не может быть запущено, пока не запущена база данных.
так же клиентское приложение не может быть запущено, пока не запущено серверное приложеие.
Во избежании увеличения размера файла было решено хранить переменные окружения в образах самих сервисов.

Далее были написаны файлы Dockerfile для клиентского и сервеного приложений(см листинг 4.10-4.11).


Листинг 4.10 – Dockerfile клиентского приложения
\begin{lstlisting}
    FROM node

    ENV PATH /node_modules/.bin:$PATH
    WORKDIR /usr/src/front

    COPY package.json ./
    COPY package-lock.json ./

    RUN npm install --silent
    RUN npm install react-scripts@3.4.1 -g --silent

    COPY . /usr/src/front/
\end{lstlisting}

Листинг 4.11 – Dockerfile серверного приложения
\begin{lstlisting}
    FROM python:3.8.0-alpine

    WORKDIR /usr/src/app

    ENV PYTHONDONTWRITEBYTECODE 1
    ENV PYTHONUNBUFFERED 1

    RUN pip install --upgrade pip
    COPY ./requirements.txt /usr/src/app/requirements.txt
    RUN pip install -r requirements.txt

    COPY . /usr/src/app/

\end{lstlisting}

Таким образом командой <<docker-compose up>> можно запустить проект.
