\section{Проектирование и разработка программного обеспечения}

Вариантом реализации архитектуры может быть монолитное приложение, когда вся или большая часть бизнес-задач имеет одну кодовую базу.
Актуальным решением в настоящее время является построенное на микросервисах приложение, в котором общая бизнес-задача разбита на отдельные части, каждая из которых имеет отдельное приложение (микросервис) со своей кодовой базой.
\bigbreak
Монолитное приложение (назовем его монолит) представляет собой приложение, доставляемое через единое развертывание.
Таким является приложение, доставленное в виде одной WAR или приложение Node с одной точкой входа.

Достоинства:
\begin{itemize}
    \item Большим преимуществом монолита является то, что его легче реализовать;
    В монолитной архитектуре вы можете быстро начать реализовывать свою бизнес-логику, вместо того чтобы тратить время на размышления о межпроцессном взаимодействие;
    \item Сквозные (E2E) тесты. В монолитной архитектуре их легче выполнить;
    \item Говоря об операциях, важно сказать, что монолит прост в развертывании и легко масштабируется.
    Для развертывания вы можете использовать скрипт, загружающий ваш модуль и запускающий приложение. Масштабирование достигается путем размещения Loadbalancer перед несколькими экземплярами вашего приложения.
    Как вы можете видеть, монолит довольно прост в эксплуатации.
\end{itemize}
Недостатки:
\begin{itemize}
    \item Монолиты, как правило, перерождаются из своего чистого состояния в так называемый «большой шарик грязи».
    Вкратце это описывается как состояние, возникшее, потому что архитектурные правила были нарушены и со временем компоненты срослись.
    Это перерождение замедляет процесс разработки: каждую будущую функцию будет сложнее развивать.
    Из-за того что компоненты растут вместе, их также необходимо менять вместе.
    Создание новой функции может означать прикосновение к 5 различным местам: 5 мест, в которых вам нужно написать тесты; 5 мест, которые могут иметь нежелательные побочные эффекты для существующих функций;
    \item Выше оговаривалось, что в монолите легко масштабировать.
    Это действительно так до тех пор, пока он не перерастет в «большой шарик грязи», как упоминалось ранее.
    Масштабирование может быть проблематичным, когда только одной части системы требуются дополнительные ресурсы, ведь в монолитной архитектуре вы не можете масштабировать отдельные части вашей системы;
    \item В монолите практически нет изоляции.
    Проблема или ошибка в модуле может замедлить или разрушить все приложение;
    \item Строительство монолита часто протекает с помощью выбора основы.
    Отключение или обновление вашего первоначального выбора может быть затруднительным, потому что это должно быть сделано сразу и для всех частей вашей системы.
\end{itemize}
\bigbreak

В микросервисной архитектуре слабо связанные сервисы взаимодействуют друг с другом для выполнения задач, относящихся к их бизнес-возможностям.

Микросервисы в значительной степени получили свое название из-за того, что сервисы здесь меньше, чем в монолитной среде. Тем не менее, микро — о бизнес-возможностях, а не о размере.

По сравнению с монолитом в микросервисах у имеется несколько единиц развертывания. Каждый сервис развертывается самостоятельно.

Достоинства:
\begin{itemize}
    \item Микросервисы легче держать модульными. Технически это обеспечивается жесткими границами между отдельными сервисами;
    \item В больших компаниях разные сервисы могут принадлежать разным командам.
    Услуги могут быть повторно использованы всей компанией.
    Это также позволяет командам работать над услугами в основном самостоятельно.
    Нет необходимости координировать развертывание между командами.
    Развивать весы лучше с увеличением количества команд;
    \item Микросервисы меньше, и благодаря этому их легче понять и проверить.
    Меньшие размеры помогают, когда речь идет о времени компиляции, времени запуска и времени, необходимом для выполнения тестов.
    Все эти факторы влияют на производительность разработчика, так как позволяют затрачивать меньше времени на ожидание на каждом этапе разработки;
    \item Более короткое время запуска и возможность развертывания микросервисов независимо друг от друга действительно выгодны для CI / CD.
    По сравнению с обычным монолитом он намного плавнее;
    \item Микросервисы не привязаны к технологии, используемой в других сервисах.
    Значит мы можем использовать лучшие технологии подгонки.
    Старые сервисы могут быть быстро переписаны для использования новых технологий;
    \item В микросервисах изолируемые разломы лучше по сравнению с монолитным подходом.
    Хорошо спроектированная распределенная система переживет сбой одного сервиса.
\end{itemize}

Недостатки:
\begin{itemize}
    \item Распределенная система имеет свою сложность: в ней вам приходится иметь дело с частичным отказом, более затруднительным взаимодействием при тестировании (тесты E2E), а также с более высокой сложностью при реализации взаимодействия между сервисами;
    \item Транзакции легче проводить в монолите.
    Решением этой проблемы на микросервисах является Saga Pattern.
    Хорошее решение, но все же слишком громоздкое для реализации на практике;
    \item Существуют эксплуатационные накладные расходы, а множество микросервисов сложнее в эксплуатации, чем несколько экземпляров сигнального монолита;
    \item Помимо вышеперечисленных сложностей, для микросервисов также может потребоваться больше оборудования, чем для традиционных монолитов.
    Иногда микросервисы могут превзойти один монолит, если есть его части, которые требуют масштабирования до предела;
    \item Изменения, затрагивающие несколько сервисов, должны координироваться между несколькими командами, а это может быть сложно, если команды еще не имели контактов.


\end{itemize}
\bigbreak

Так как дипломный проект представляет из себя хоть и законченный проект, но в то же время прототип, то было решено использовать монолитную архитектуру реализации проекта.
Несмотря на это, по причине того, что серверная часть написана на Django, который под собой разбивает приложение на набор небольших приложения, проблем с масштабированием данного приложения на сервисную архитектуру не должен составить труда.


\subsection{Проектирование базы данных БД}

\subsubsection{Инфологическое проектирование БД}
Первостепенной моделью данного проекта является пользователь, который при регистрации указывает свои контактные данные и краткую информацию о себе.

При регистрации пользователь выбирает себе аватар.

Пользователь может создать товар, заполнив некоторый набор полей о товаре.

При создании товара пользователь может добавлять некоторое количество фотографий товара и определять его в некоторые категории.

Пользователь может положить товар к себе в корзину.

Пользователь может купить товар в аренду либо сдать его.

Пользователь может сохранить методы оплаты.

Пользователь может созранить адрес доставки товара.

Пользователь может оставлять отзывы о других пользователях.

Таким образом можно выделить сущности:
\begin{itemize}
    \item User – сущность, представляющая пользователя;
    \item Good - сущность, представляющая товар в системе;
    \item UserAvatar – сущность, предстваляющая аватар пользователя;
    \item GoodAvatar - сущность, представляющая фотографию товара;
    \item Tag - сущность, представляющая категории товара;
    \item Basket - сущность, предстввляющая корзину товаров пользователя;
    \item Payment - сущность, представляющая метод оплаты пользователя;
    \item Address - сущность, представляющая адрес доставки пользователя;
    \item Review - сущность, представляющая отзыв пользователя о пользователе;
    \item Order - сущность, представляющая товар, взятый в аренду пользователем.
\end{itemize}

Выделив сущности, можно составить связи между ними:
\bigbreak

\begin{tabular}{ | l | l | l | }
\hline
Родительская сущность & Дочерняя сущность & Тип связи  \\ \hline
User & UserAvatar & один-к-одному \\ \hline
User & Basket & один-к-одному \\ \hline
User & Good & один-ко-многим \\ \hline
Good & GoodsAvatar & один-ко-многим \\ \hline
Good & Tag & многие-ко-многим \\ \hline
User & Payment & один-ко-многим \\ \hline
User & Address & один-ко-многим \\ \hline
User & Order & один-ко-многим \\ \hline
User & Review & многие-ко-многим \\ \hline
Basket & Good & многие-ко-многим \\
\hline
\end{tabular}

\subsubsection{Даталогическое проектирование БД}
На основании выделенных сущностей и связей. Ниже приведены таблицы, популяризированные атрибутами.


User:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    name & varchar(120) & ФИО пользователя \\ \hline
    phone & varchar(20) & Номер телефона пользователя \\ \hline
    email & varchar(30) & Электронная почта пользователя \\ \hline
    created\_at & datetime & Дата создания пользователя \\
    \hline
\end{tabular}
\bigbreak


Good:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    name & varchar(120) & название товара \\ \hline
    condition & int & состояние товара \\ \hline
    description & varchar(120) & краткое описание товара \\ \hline
    can\_be\_purchased & int & поле, идтицируещее возможность выкупа товара \\ \hline
    price\_per\_hour & int & цена за час аренды \\ \hline
    price\_per\_day & int & цена за сутки аренды \\ \hline
    own\_deliver & int & поле, индицируещее возможность доставки арендатором\\
    \hline
\end{tabular}
\bigbreak



UserAvatar:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    url & varchar(120) & url-адрес на фотография \\ \hline
    user & int & указатель на пользователя \\
    \hline
\end{tabular}
\bigbreak

GoodAvatar:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    url & varchar(120) & url-адрес на фотография \\ \hline
    good & int & указатель на товар \\
    \hline
\end{tabular}
\bigbreak

Tag:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    name & varchar(120) & название категории \\
    \hline
\end{tabular}
\bigbreak

TagGood:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    tag & int & указатель на категорию \\ \hline
    good & int & указатель на товар \\
    \hline
\end{tabular}
\bigbreak

Basket:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    user & int & указатель на пользователя \\
    \hline
\end{tabular}
\bigbreak

BasketGood:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    basket & int & указатель на корзину \\ \hline
    good & int & указатель на товар \\
    \hline
\end{tabular}
\bigbreak

Payment:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    user & int & указатель на пользователя \\ \hline
    card\_number & varchar(30) & номер карты \\ \hline
    cvv\_code & varchar(3) & cvv код карты \\ \hline
    date\_expire & varchar(10) & срок годности карты \\ \hline
    cardholder\_name & varchar(50) & имя держателя карты \\
    \hline
\end{tabular}
\bigbreak

Address:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    user & int & указатель на пользователя \\ \hline
    city & varchar(20) & Город в адресе \\ \hline
    street & varchar(20) & улица в адресе \\ \hline
    building & varchar(10) & номер здания  \\ \hline
    appartament & int & номер квартиры \\
    \hline
\end{tabular}
\bigbreak

Review:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    sender & int & указатель на пользователя, оставившего отзыв \\ \hline
    receiver & int & указатель на пользователя, получивший отзыв \\ \hline
    text & varchar(120) & текстовый отзыв \\ \hline
    mark & int & оценка в отзыве \\
    \hline
\end{tabular}
\bigbreak

Order:
\bigbreak
\begin{tabular}{ | l | l | l | }
    \hline
    Атрибут & Тип данных & Описание  \\ \hline
    good & int & указатель указатель на арендатора \\ \hline
    created\_at & datetime & дата создания товара  \\ \hline
    start\_use\_date & datetime & начальная дата аренды товара \\ \hline
    end\_use\_date & datetime & дата сдачи товраа обратно \\
\hline
\end{tabular}

\subsubsection{Нормализация БД}
Написать про нормализацию БД

Добавить приложение с ER диаграммой

\subsection{Построение диаграммы компонентов}
\subsubsection{Построение диаграммы компонентов серверной части}
Описать структуру бека, взаимодействия с БД и Firebase
Добавить приложение с диаграммой

\subsubsection{Построение диаграммы компонентов клиентской части}
Описать структуру фронта, взаимодейтсвие с фаербейзом, беком и редаксом
Добавить приложение с диаграммой

\subsection{Построение диаграммы компонентов}
\subsubsection{Построение диаграммы последовательности серверной части}
описать процесс сдачи товара в аренду со стороны бека
Добавить приложение с диаграммой

\subsubsection{Построение диаграммы последовательности клиентской части}
описать процесс сдачи товара в аренду со стороны фронта
Добавить приложение с диаграммой

\subsection{Построение диаграммы развертывания}
Описать развертывание docker-compose на сервере(например DigitalOcean)
Добавить приложение с диаграммой
